via
vi ascended
visual ascended

mo
modal
modal editor

md
modal
modal editor

watch uzaki chan wants to hang out
or watch advanced C course on youtube
- the classic c dilemma 

wanted features:
generate a hash of the whole file: MD5, SHA256, SHA512
real encryption
compression
eol skip via key combo or something, useful
delete whole word
delete line
splash screen

int skip_eol(char *a)
  use memchr to find first newline
  occurence, position specifically

horizontal cursor position:
count how many characters you 
are out from the last newline 
(only fire on up down movements)

vertical cursor position:
count how many newlines there are
from the start of the buffer to the
end
(only fire on up down movements)

going up:
if you go up to a line with less characters
than the current horizontal position, then
clamp the horizontal position to the line, 
and vice versa

check if file has lines longer than 65536 bytes
if no - line lengths are u shorts
if yes - line lengths are u ints

modes:
normal
real terminal
vi terminal
insert

VSCODE THEME:
Monokai pro, filter: machine

####
VINOTES FROM IMA:
####


create an struct for editor controls for each mode
initialize the struct based on configs and file data

BUFFER IDEAS:
char *buffer
char *pos 
OR
char *buffer
off_t pos
(im thinking second, valid after realloc)

struct controls_normal {
  int d_l; /* delete */
  int u_p; /* cursor up */
}

open(config, ORDONLY)
/* use inih or some other config library here */

INTERFACE IDEAS:
ncurses - wide support, proven
notcurses - fast, complicated
termbox - simple, small, less features
tuibox - more like a retained mode tui library
vt100utils - utility for escape sequences

struct vi_op {
  off_t o; /* offset */
  viu8  f; /* operation, as in DELETE or INSERT */
  viu8  c; /* char */ 
}

UNDO REDO LOGIC:
Stack based for each, 
with dynamic growing and shrinking

UNDO STACK
REDO STACK
LAST OPERATION


if UNDO_KEY pressed 


ehh, get rid of the typedefs anyway it just makes it confusing

compare offset address to the array of line pointers
struct {
  size_t * lar; /* line sizes array */
  size_t   las; /* line sizes array size */
  off_t    als; /* array of line starts */
  size_t   lss; /* array of line starts size */
}

do a binary search i guess:
"To find the line you are currently in, you do a binary search on this array to find the greatest line start offset <= your current offset."
(talking about the array of line starts) 
